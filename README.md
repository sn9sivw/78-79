# infoles_78-79
### Ответы на вопросы

1. **Чем различаются понятия «шифрование» и «кодирование»?**

   - **Кодирование** — это процесс преобразования информации в форму, удобную для передачи или хранения, но сама информация остаётся понятной любому, кто знает правила кодирования. Например, ASCII-кодировка текста — это кодирование, но не шифрование.
   - **Шифрование** — это процесс преобразования информации в такую форму, которая становится недоступной для прочтения без знания специального ключа или метода дешифровки. Целью шифрования является защита информации от несанкционированного доступа.

2. **Что такое ключ?**

   Ключ — это секретная информация, используемая для шифрования и дешифрования сообщений. Ключ определяет конкретное преобразование, применяемое к данным при шифровании и дешифровании. В зависимости от типа шифра (симметричное или асимметричное) ключи могут различаться по своей структуре и использованию.

3. **Как называется наука, изучающая методы шифрования?**

   Наука, изучающая методы шифрования, называется **криптография**. Она включает разработку и анализ методов защиты информации, включая шифрование, хеширование и цифровые подписи.

4. **Что такое симметричный шифр? Какая проблема возникает при использовании симметричного шифра, если участники переписки находятся в разных странах?**

   Симметричный шифр — это такой шифр, в котором для шифрования и дешифрования используется один и тот же ключ. Проблема состоит в необходимости безопасного обмена этим ключом между участниками коммуникации. Если участники находятся в разных странах, передача ключа может стать уязвимой для перехвата злоумышленниками.

5. **Что такое несимметричные шифры? На чём основана их надёжность?**

   Несимметричные шифры используют разные ключи для шифрования и дешифрования. Обычно один ключ является открытым и доступен всем, а второй ключ остаётся закрытым и известен только владельцу. Надёжность несимметричных шифров основывается на сложности математических проблем, таких как задача факторизации больших чисел или дискретное логарифмирование.

6. **Что такое криптостойкость алгоритма? Какой алгоритм считается криптостойким?**

   Криптостойкость алгоритма — это мера устойчивости алгоритма к криптоанализу, то есть насколько сложно взломать данный алгоритм, зная его принцип работы. Алгоритмы считаются криптостойкими, если их нельзя взломать быстрее, чем путём полного перебора всех возможных ключей.

---

### Решение задач

1. **Зашифруйте с помощью шифра Цезаря со сдвигом 6 высказывание «люди охотно верят тому, чему желают верить».**

   Шифр Цезаря использует смещение букв на заданное число позиций вперёд по алфавиту. В данном случае, сдвиг составляет 6 позиций.

   Исходное сообщение: `люди охотно верят тому, чему желают верить`

   Шифрованное сообщение: `опа уьжпо верят тому, чеу желают верить`

2. **Напишите программу, которая выполняет шифрование строки с помощью шифра Цезаря.**

   ```python
   def caesar_cipher(message, shift):
       encrypted_message = ''
       for char in message:
           if not char.isalpha():
               encrypted_message += char
           else:
               new_char = chr(ord(char) + shift % 26)
               encrypted_message += new_char
       return encrypted_message

   message = input("Введите сообщение для шифрования: ")
   shift = int(input("Введите величину сдвига: "))

   print(caesar_cipher(message, shift))
   ```

3. **Попытайтесь расшифровать сообщение, закодированное шифром Цезаря с неизвестным сдвигом: «ХШЖНПУТ ФКХКОЙКТ». Для этого можно написать программу.**

   Поскольку сдвиг в шифре Цезаря неизвестен, программа должна попытаться применить различные возможные сдвиги и проверить результат на наличие осмысленного сообщения.

   ```python
   def decrypt_caesar(cipher_text):
       possible_messages = {}
       for shift in range(1, 26):
           decrypted_message = caesar_cipher(cipher_text, -shift)
           possible_messages[decrypted_message] = shift
       return possible_messages

   cipher_text = "ХШЖНПУТ ФКХКОЙКТ"
   messages = decrypt_caesar(cipher_text)

   for message in messages.keys():
       print(f"Ключ: {messages[message]}, Сообщение: {message}")
   ```

4. **Используя шифр Виженера с ключом «ЛЕНА», зашифруйте сообщение «НЕЛЬЗЯ ОБИЖАТЬ ГОСТЯ».**

   Шифр Виженера использует ключ для шифрования каждого символа сообщения. Ключ многократно повторяется, чтобы обеспечить достаточное количество символов для шифрования всего сообщения.

   **Исходное сообщение:** `НЕЛЬЗЯ ОБИЖАТЬ ГОСТЯ`

   **Ключ:** `ЛЕНАЛЕНАЛЕНА`

   **Шифрование:**
   - Первая буква "Н" шифруется первой буквой ключа "Л": ("Н" + "Л") mod 26 = "Б"
   - Вторая буква "Е" шифруется второй буквой ключа "Е": ("Е" + "Е") mod 26 = "Е"
   - Третья буква "Л" шифруется третьей буквой ключа "Н": ("Л" + "Н") mod 26 = "Р"
   - Четвёртая буква "Ь" шифруется четвёртой буквой ключа "А": ("Ь" + "А") mod 26 = "Э"
   - Пятая буква "З" шифруется пятой буквой ключа "Л": ("З" + "Л") mod 26 = "И"
   - Шестая буква "Я" шифруется шестой буквой ключа "Е": ("Я" + "Е") mod 26 = "Я"
   - Седьмая буква " " (пробел) шифруется седьмой буквой ключа "Н": пробелы остаются неизменными.
   - Восьмая буква "О" шифруется восьмой буквой ключа "А": ("О" + "А") mod 26 = "Т"
   - Девятая буква "Б" шифруется девятой буквой ключа "Л": ("Б" + "Л") mod 26 = "Ф"
   - Десятая буква "И" шифруется десятой буквой ключа "Е": ("И" + "Е") mod 26 = "И"
   - Одиннадцатая буква "Ж" шифруется одиннадцатой буквой ключа "Н": ("Ж" + "Н") mod 26 = "Ж"
   - Двенадцатая буква "А" шифруется двенадцатой буквой ключа "А": ("А" + "А") mod 26 = "А"
   - Тринадцатая буква "Т" шифруется тринадцатой буквой ключа "Л": ("Т" + "Л") mod 26 = "У"
   - Четырнадцатая буква "'" (апостроф) шифруется четырнадцатой буквой ключа "Е": апострофы остаются неизменными.

   Итоговое зашифрованное сообщение: `БРЭИРЖАЭ Т ФИЛЭКТ`

5. **Измените программу для шифрования с помощью шифра Цезаря так, чтобы учитывать букву Ё.**

   Программа должна проверять, является ли буква "Ё" и правильно обрабатывать её при шифровании.

   ```python
   def caesar_cipher(message, shift):
       encrypted_message = ''
       for char in message:
           if not char.isalpha():
               encrypted_message += char
           else:
               new_char = chr(ord(char) + shift % 32)
               encrypted_message += new_char
       return encrypted_message

   message = input("Введите сообщение для шифрования: ")
   shift = int(input("Введите величину сдвига: "))
   print(caesar_cipher(message, shift))
   ```

6. **Измените программу для шифрования с помощью шифра Цезаря так, чтобы учитывать и букву Ё, и пробел.**

   Программа должна корректно обрабатывать как букву "Ё", так и пробелы.

   ```python
   def caesar_cipher(message, shift):
       encrypted_message = ''
       for char in message:
           if char == 'Ё':
               new_char = chr(ord(char) + shift % 27)
               encrypted_message += new_char
           elif char.isalpha():
               new_char = chr(ord(char) + shift % 26)
               encrypted_message += new_char
           else:
               encrypted_message += char
       return encrypted_message

   message = input("Введите сообщение для шифрования: ")
   shift = int(input("Введите величину сдвига: "))
   print(caesar_cipher(message, shift))
   ```

79&
### Что такое хэширование? Хэш-функции? Хэш-коды?

**Хэширование** — это процесс преобразования данных в компактное представление, которое сохраняет основные характеристики исходных данных, но занимает меньше места в памяти. Этот процесс осуществляется с помощью специальных функций, называемых **хэш-функциями**, которые принимают на входе данные и возвращают уникальный **хэш-код** — фиксированный размер данных, который однозначно идентифицирует исходные данные.

**Хэш-функция** — это математическая функция, которая принимает на вход произвольные данные и возвращает фиксированный размер данных (обычно фиксированную длина байтов). Это делается для того, чтобы обеспечить однозначность представления данных, а также избежать дублирования.

**Хэш-код** — это результат работы хэш-функции над данными. Он представляет собой уникальное представление данных фиксированного размера, которое можно использовать для проверки целостности данных, поиска в базах данных и других целей.

### Какую хэш-функцию вы используете, когда начинаете искать слово в словаре?

При поиске слова в словаре используется специальная хэш-функция, которая позволяет быстро находить нужное слово по его индексу. Процесс начинается с вычисления индекса для данного слова с помощью хэш-функции, после чего происходит переход к нужному месту в словаре.

### Что такое коллизии? Почему их должно быть как можно меньше?

**Коллизии** — это ситуация, когда два или более элементов данных имеют одинаковый хэш-код. В контексте хэш-функций это означает, что несколько различных данных приводят к одному и тому же хэш-коду. Коллизии являются проблемой, потому что они затрудняют точное определение уникальных данных, делая возможным ложные совпадения.

Причины возникновения коллизий:
1. Ограниченный диапазон значений хэш-кодов. Так как хэш-функция возвращает фиксированный размер данных, то при большом количестве данных вероятность коллизий возрастает.
2. Случайные события. Вероятность случайных событий (например, коллизий) возрастает с увеличением количества обрабатываемых данных.

Причины важности минимизации коллизий:
1. **Эффективность поиска.** Коллизии увеличивают затраты на поиск в базе данных, так как требуется дополнительная проверка, чтобы убедиться, что найденный элемент действительно соответствует искомым данным.
2. **Безопасность**. Коллизии могут приводить к ошибкам в идентификации данных, что создаёт риски безопасности, особенно в критичных приложениях, где важна точная идентификация данных.

### Какие требования предъявляются к хэш-функциям, которые используются при хранении паролей?

При хранении паролей к хэш-функциям предъявляются строгие требования:

1. **Криптостойкость.** Хэш-функции должны быть устойчивыми к атакам методом полного перебора (brute force attack), когда злоумышленнику известно часть пароля.

2. **Устойчивость к атакам по времени.** Даже если злоумышленец знает часть пароля, восстановление полного пароля должно занимать много времени.

3. **Невосприимчивость к атакам на аппаратном уровне.** Физический доступ к устройству, на котором хранятся пароли, не должен давать возможности восстановить пароль.

4. **Необратимость.** После применения хэш-функции к паролю, его невозможно восстановить обратно.

### Что значит «вычислительно невозможно»?

Выражение «вычислительно невозможно» означает, что задачу невозможно решить за разумное время с использованием современных вычислительных средств. Это связано с тем, что для решения задачи требуются значительные вычислительные мощности, время или специальные методы, которые делают задачу практически неразрешимой с практической точки зрения.

Примером задачи, которая считается вычислительно невозможной, является задача факторизации большого числа. Современные компьютеры не способны решать эту задачу за приемлемые сроки, и именно поэтому криптографические системы строятся на предположении, что факторизация больших чисел занимает неприемлемо много времени.

### Взломщик узнал хэш-код пароля администратора сервера. Сможет ли он получить доступ к секретным данным на сервере?

Даже если злоумышленцу удастся узнать хэш-код пароля администратора, это само по себе не гарантирует получения доступа к секретным данным на сервере. Причина в том, что большинство современных систем используют дополнительные меры безопасности, такие как **salt** (соль) и **iterated hashing** (повторное хэширование), которые усложняют процесс восстановления пароля из хэш-кода.

### Какую роль играют свойства пароля в его надежности?

Надёжность пароля напрямую зависит от его свойств:

1. **Длина пароля.** Чем длиннее пароль, тем сложнее его подобрать методом перебора.
2. **Сложность пароля.** Пароль должен содержать буквы разного регистра, цифры, символы и знаки пунктуации, чтобы увеличить энтропию (сложность подбора).
3. **Разнообразие символов.** Использование разнообразных символов увеличивает количество комбинаций, что усложняет подбор пароля.
4. **Частота смены пароля.** Регулярная смена пароля уменьшает шансы взломщика на успех, так как старый пароль теряет актуальность.

### Как выбрать надежный пароль?

При выборе надёжного пароля следует учитывать следующие рекомендации:

1. **Длина пароля.** Минимально рекомендуемая длина пароля — 8–16 символов.
2. **Смешанность символов.** Используйте буквы верхнего и нижнего регистров, цифры, спецсимволы и знаки пунктуации.
3. **Использование специальных символов.** Включайте в пароль нестандартные символы, такие как знаки препинания, кавычки, скобки и угловые скобки.
4. **Периодическая замена пароля.** Меняйте пароль каждые 30–60 дней, чтобы минимизировать риск утечки старых паролей.

### Какие алгоритмы хэширования чаще всего применяются?

Наиболее распространённые алгоритмы хэширования:

1. **MD5 (Message Digest 5)**. Один из самых популярных алгоритмов хэширования, однако считается устаревающим и подверженным атакам.
2. **SHA-256 (Secure Hash Algorithm 256)**. Более современный и криптостойкий алгоритм, который заменил MD5 в большинстве случаев.
3. **RIPEMD-160 (Rivest Security Institute's Message Digest 160)**. Используется в качестве замены SHA-256 в некоторых случаях, когда требуется ещё больший уровень криптостойкости.
4. **Argon2 (Advanced Encryption Standard 2)**. Новый стандарт шифрования, разработанный для замены AES-128 и обладающий повышенной стойкостью к атакам.

Эти алгоритмы являются основными инструментами в криптографии для обеспечения надёжности данных.

### Задачи

#### Задача 1: Написание программы для оценки времени перебора пароля

Программа оценивает время, необходимое для перебора пароля методом грубой силы.

```python
def brute_force_time(password_length, password_complexity, speed):
    seconds_to_crack = (password_length * password_complexity) / speed
    return seconds_to_crack

# Пример использования функции
password_length = 15
password_complexity = 1024
speed = 10000000
result = brute_force_time(password_length, password_complexity, speed)
print(result)
```

### Задача 2: Оценка времени перебора пароля

Оценивание времени перебора пароля для различных типов паролей:

1. Только цифры:

```python
seconds_to_crack = (password_length * 10) / speed
return seconds_to_crack
```

2. Заглавные латинские буквы и цифры:

```python
password_length = 8
password_complexity = 36 * 10
speed = 10000000
result = brute_force_time(password_length, password_complexity, speed)
print(result)
```

3. Латинские буквы (заглавные и строчные) и цифры:

```python
password_length = 14
password_complexia = 62 * 10
speed = 10000000
result = brute_force_time(password_length, password_complexity, speed)
print(result)
```

### Задача 3: Выбор длины пароля для защиты

Определение минимальной длины пароля для защиты от атаки:

1. Только цифры:

```python
password_length = 8
password_complexity = 10
speed = 10000000
result = brute_force_time(password_length, password_complexity, speed)
print(result)
```

2. Заглавные латинские буквы и цифры:

```python
password_length = 8
password_complexity = 36 * 10
speed = 10000000
result = bruite_force_time(password_length, password_complexity, speed)
print(result)
```

3. Латинские буквы (заглавные и строчные) и цифры:

```python
password_length = 14
password_complexity = 62 * 10
speed = 10000000
result = bruite_force_time(password_length, password_complexity, speed)
print(result)
```

### Задача 4: Генерация надёжного пароля

Создание программы для генерации надёжного пароля:

```python
import random
import string

def generate_password(length, complexity):
    symbols = list(range('a', 'z'))
    symbols.extend(['!', '@', '-', '+', '*', '(', ')'])
    random.shuffle(symbols)
    password = ''.join(random.choice(symbols) for _ in range(length)):
        if random.choice(symbols) == ' ':
            continue
        if random.choice(symbols) == '\'':
            password += "'"

    return password

length = 24
complexity = 262144
random.seed(123456789)
print(generate_password(length, complexity))
```

### Задачи 5: Анализ алгоритмов хэширования

Анализ наиболее распространенных алгоритмов хэширования:

1. **MD5**:
   - **Преимущества**: Легкость использования, универсальность.
   - **Недостатки**: Низкая криптостойкость, подверженность атакам.

2. **SHA-256**:
   - **Преимущества**: Высокая криптостойкость, широкое применение.
   - **Недостатки**: Возможны атаки на конкретные реализации.
3. **RIPEMD-160**:
   - **Преимущества**: Улучшенная криптостойкость по сравнению с SHA-256.
   - **Недостатки**: Меньше распространён, чем SHA-256.
4. **Argon2**:
   - **Преимущества**: Самый новый стандарт, повышенная криптостойкость.
   - **Недостатки**: Пока не получил широкого распространения.
